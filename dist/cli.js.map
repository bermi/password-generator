{
  "version": 3,
  "sources": ["../src/random.ts", "../src/index.ts", "../src/cli.ts"],
  "sourcesContent": [
    "const crypto = globalThis.crypto!;\nconst MAX_RANDOM_BYTES = 65_536;\n\ntype RandomBytes = (length: number) => Promise<Uint8Array>;\ntype CryptoSource = Pick<Crypto, \"getRandomValues\" | \"subtle\">;\n\nexport const getRandomBytes: RandomBytes = async (\n  length: number,\n): Promise<Uint8Array> => {\n  if (!Number.isFinite(length) || length < 0) {\n    throw new RangeError(\"length must be a non-negative finite number\");\n  }\n\n  const buffer = new Uint8Array(length);\n  for (let offset = 0; offset < length; offset += MAX_RANDOM_BYTES) {\n    const end = Math.min(offset + MAX_RANDOM_BYTES, length);\n    crypto.getRandomValues(buffer.subarray(offset, end));\n  }\n  return buffer;\n};\n\nexport const createDeterministicRandomBytes = async (\n  entropy: Uint8Array,\n  cryptoSource: CryptoSource = crypto,\n): Promise<RandomBytes> => {\n  if (entropy.length === 0) {\n    throw new RangeError(\"entropy must not be empty\");\n  }\n  if (!cryptoSource.subtle) {\n    throw new Error(\"WebCrypto subtle is required for deterministic entropy\");\n  }\n\n  const keyData = new Uint8Array(entropy).buffer;\n  const key = await cryptoSource.subtle.importKey(\"raw\", keyData, { name: \"HMAC\", hash: \"SHA-256\" }, false, [\"sign\"]);\n\n  let counter = 0n;\n  const counterBytes = new Uint8Array(8);\n  const counterView = new DataView(counterBytes.buffer);\n  counterView.setBigUint64(0, counter, false);\n  const deterministicRandomBytes: RandomBytes = async (length: number) => {\n    if (!Number.isFinite(length) || length < 0) {\n      throw new RangeError(\"length must be a non-negative finite number\");\n    }\n\n    const buffer = new Uint8Array(length);\n    let offset = 0;\n\n    while (offset < length) {\n      counterView.setBigUint64(0, counter, false);\n      counter += 1n;\n      const block = new Uint8Array(\n        await cryptoSource.subtle.sign(\"HMAC\", key, counterBytes),\n      );\n      const take = Math.min(block.length, length - offset);\n      buffer.set(block.subarray(0, take), offset);\n      offset += take;\n    }\n\n    return buffer;\n  };\n\n  return deterministicRandomBytes;\n};\n\nexport const randomInt = async (\n  min: number,\n  max: number,\n  randomBytes: RandomBytes = getRandomBytes,\n): Promise<number> => {\n  if (!Number.isFinite(min) || !Number.isFinite(max)) {\n    throw new RangeError(\"min and max must be finite numbers\");\n  }\n  if (max <= min) {\n    throw new RangeError(\"max must be greater than min\");\n  }\n\n  const range = max - min;\n  if (range === 1) {\n    return min;\n  }\n\n  const bytesNeeded = Math.ceil(Math.log2(range) / 8);\n  const maxValue = 256 ** bytesNeeded;\n  const limit = maxValue - (maxValue % range);\n\n  let value = limit;\n  while (value >= limit) {\n    const bytes = await randomBytes(bytesNeeded);\n    value = 0;\n    for (const byte of bytes) {\n      value = value * 256 + byte;\n    }\n  }\n\n  return min + (value % range);\n};\n",
    "import {\n  createDeterministicRandomBytes,\n  getRandomBytes,\n  randomInt,\n} from \"./random.js\";\n\nexport type GenerateOptions = {\n  length?: number;\n  memorable?: boolean;\n  pattern?: RegExp;\n  prefix?: string;\n  ignoreSecurityRecommendations?: boolean;\n  entropy?: Uint8Array | string;\n  words?: number;\n};\n\nconst VOWELS = \"aeiou\";\nconst CONSONANTS = \"bcdfghjklmnpqrstvwxyz\";\nconst VOWEL = new RegExp(`[${VOWELS}]$`, \"i\");\nconst CONSONANT = new RegExp(`[${CONSONANTS}]$`, \"i\");\nconst DEFAULT_PATTERN = /\\w/;\nconst DEFAULT_LENGTH = 12;\nconst MIN_ENTROPY_BITS = 64;\nconst MIN_WORD_LENGTH = 3;\nconst MAX_WORD_LENGTH = 7;\nconst textEncoder = new TextEncoder();\n\nconst normalizeOptions = (options: GenerateOptions | undefined) => {\n  const lengthRaw = options?.length;\n  const memorableRaw = options?.memorable;\n  const patternRaw = options?.pattern;\n  const prefixRaw = options?.prefix;\n  const ignoreSecurityRecommendationsRaw =\n    options?.ignoreSecurityRecommendations;\n  const entropyRaw = options?.entropy;\n  const wordsRaw = options?.words;\n\n  const length = lengthRaw ?? DEFAULT_LENGTH;\n  const memorable = memorableRaw ?? false;\n  const pattern = patternRaw ?? DEFAULT_PATTERN;\n  const prefix = prefixRaw ?? \"\";\n\n  return {\n    length,\n    memorable,\n    pattern,\n    prefix: String(prefix),\n    ignoreSecurityRecommendations: ignoreSecurityRecommendationsRaw ?? false,\n    entropy: entropyRaw,\n    words: wordsRaw,\n  };\n};\n\nconst ensureSafeInteger = (value: number, name: string) => {\n  if (!Number.isSafeInteger(value)) {\n    throw new RangeError(`${name} must be a safe integer`);\n  }\n};\n\nconst ensureRegExp = (value: unknown) => {\n  if (!(value instanceof RegExp)) {\n    throw new TypeError(\"pattern must be a RegExp\");\n  }\n};\n\nconst normalizeEntropy = (entropy: Uint8Array | string | undefined) => {\n  if (entropy === undefined) {\n    return undefined;\n  }\n  if (typeof entropy === \"string\") {\n    return textEncoder.encode(entropy);\n  }\n  if (entropy instanceof Uint8Array) {\n    return entropy;\n  }\n  throw new TypeError(\"entropy must be a Uint8Array or string\");\n};\n\nconst matchesPattern = (pattern: RegExp, char: string) => {\n  pattern.lastIndex = 0;\n  return pattern.test(char);\n};\n\nconst buildValidChars = (pattern: RegExp) => {\n  const validChars: string[] = [];\n  for (let i = 33; i <= 126; i += 1) {\n    const char = String.fromCharCode(i);\n    if (matchesPattern(pattern, char)) {\n      validChars.push(char);\n    }\n  }\n  if (validChars.length === 0) {\n    throw new Error(\n      `Could not find characters that match the password pattern ${pattern}. Patterns must match individual characters, not the password as a whole.`,\n    );\n  }\n  return validChars;\n};\n\nconst estimatePatternEntropy = (\n  alphabetSize: number,\n  length: number,\n  prefix: string,\n) => {\n  const effectiveLength = Math.max(0, length - prefix.length);\n  const bitsPerChar = alphabetSize > 1 ? Math.log2(alphabetSize) : 0;\n  const entropyBits = bitsPerChar * effectiveLength;\n  const recommendedLength =\n    bitsPerChar > 0\n      ? prefix.length + Math.ceil(MIN_ENTROPY_BITS / bitsPerChar)\n      : null;\n\n  return {\n    effectiveLength,\n    entropyBits,\n    recommendedLength,\n  };\n};\n\nconst estimateMemorableEntropy = (length: number, prefix: string) => {\n  const effectiveLength = Math.max(0, length - prefix.length);\n  let entropyBits = 0;\n  let expectsVowel = CONSONANT.test(prefix);\n\n  for (let i = 0; i < effectiveLength; i += 1) {\n    const alphabetSize = expectsVowel ? VOWELS.length : CONSONANTS.length;\n    entropyBits += Math.log2(alphabetSize);\n    expectsVowel = !expectsVowel;\n  }\n\n  let recommendedLength = prefix.length;\n  let recommendationBits = 0;\n  expectsVowel = CONSONANT.test(prefix);\n  while (recommendationBits < MIN_ENTROPY_BITS) {\n    const alphabetSize = expectsVowel ? VOWELS.length : CONSONANTS.length;\n    recommendationBits += Math.log2(alphabetSize);\n    expectsVowel = !expectsVowel;\n    recommendedLength += 1;\n  }\n\n  return {\n    effectiveLength,\n    entropyBits,\n    recommendedLength,\n  };\n};\n\nconst MEMORABLE_RECOMMENDED_LENGTH = estimateMemorableEntropy(\n  0,\n  \"\",\n).recommendedLength;\n\nconst buildMemorableWord = async (\n  length: number,\n  nextInt: (min: number, max: number) => Promise<number>,\n) => {\n  let expectsVowel = false;\n  let word = \"\";\n\n  for (let i = 0; i < length; i += 1) {\n    const alphabet = expectsVowel ? VOWELS : CONSONANTS;\n    const index = await nextInt(0, alphabet.length);\n    word += alphabet[index] ?? \"\";\n    expectsVowel = !expectsVowel;\n  }\n\n  return word;\n};\n\nconst buildWordLengths = async (\n  count: number,\n  nextInt: (min: number, max: number) => Promise<number>,\n  targetLength?: number,\n) => {\n  const lengths: number[] = [];\n  let total = 0;\n\n  for (let i = 0; i < count; i += 1) {\n    const length = await nextInt(MIN_WORD_LENGTH, MAX_WORD_LENGTH + 1);\n    lengths.push(length);\n    total += length;\n  }\n\n  if (targetLength !== undefined && total < targetLength) {\n    const adjustable = Array.from({ length: count }, (_, idx) => idx);\n    let remaining = targetLength - total;\n\n    while (remaining > 0 && adjustable.length > 0) {\n      const pickIndex = await nextInt(0, adjustable.length);\n      const wordIndex = adjustable[pickIndex];\n      if (wordIndex === undefined) {\n        break;\n      }\n      const currentLength = lengths[wordIndex];\n      if (currentLength === undefined) {\n        break;\n      }\n      if (currentLength < MAX_WORD_LENGTH) {\n        lengths[wordIndex] = currentLength + 1;\n        remaining -= 1;\n        if (lengths[wordIndex] === MAX_WORD_LENGTH) {\n          adjustable.splice(pickIndex, 1);\n        }\n      } else {\n        adjustable.splice(pickIndex, 1);\n      }\n    }\n  }\n\n  return lengths;\n};\n\nconst securityRecommendation = (reason: string, recommendation: string) => {\n  throw new Error(\n    `Security recommendation: ${reason}. ${recommendation} To override, pass { ignoreSecurityRecommendations: true }.`,\n  );\n};\n\nexport const generatePassword = async (\n  length?: number,\n  memorable?: boolean,\n  pattern?: RegExp,\n  prefix?: string,\n): Promise<string> => {\n  const options: GenerateOptions = {};\n  if (length !== undefined) {\n    options.length = length;\n  }\n  if (memorable !== undefined) {\n    options.memorable = memorable;\n  }\n  if (pattern !== undefined) {\n    options.pattern = pattern;\n  }\n  if (prefix !== undefined) {\n    options.prefix = prefix;\n  }\n\n  return generatePasswordWithOptions(\n    Object.keys(options).length ? options : undefined,\n  );\n};\n\nexport const generatePasswordWithOptions = async (\n  options?: GenerateOptions,\n): Promise<string> => {\n  const {\n    length,\n    memorable,\n    pattern,\n    prefix,\n    ignoreSecurityRecommendations,\n    entropy,\n    words,\n  } = normalizeOptions(options);\n\n  ensureSafeInteger(length, \"length\");\n  if (length < 0) {\n    throw new RangeError(\"length must be a non-negative integer\");\n  }\n  ensureRegExp(pattern);\n  if (words !== undefined) {\n    ensureSafeInteger(words, \"words\");\n    if (words <= 0) {\n      throw new RangeError(\"words must be a positive integer\");\n    }\n  }\n  if (words !== undefined && prefix !== \"\") {\n    throw new Error(\"prefix is not supported when words are enabled\");\n  }\n\n  const entropyBytes = normalizeEntropy(entropy);\n  const randomBytes = entropyBytes\n    ? await createDeterministicRandomBytes(entropyBytes)\n    : getRandomBytes;\n  const nextInt = (min: number, max: number) =>\n    randomInt(min, max, randomBytes);\n\n  if (words !== undefined) {\n    if (\n      !ignoreSecurityRecommendations &&\n      words * MAX_WORD_LENGTH < MEMORABLE_RECOMMENDED_LENGTH\n    ) {\n      const recommendedWords = Math.ceil(\n        MEMORABLE_RECOMMENDED_LENGTH / MAX_WORD_LENGTH,\n      );\n      securityRecommendation(\n        `word count ${words} cannot reach ${MIN_ENTROPY_BITS} bits with ${MIN_WORD_LENGTH}-${MAX_WORD_LENGTH} letter words`,\n        `Use words >= ${recommendedWords}.`,\n      );\n    }\n\n    const targetLength = ignoreSecurityRecommendations\n      ? undefined\n      : MEMORABLE_RECOMMENDED_LENGTH;\n    const lengths = await buildWordLengths(words, nextInt, targetLength);\n    const wordsList: string[] = [];\n\n    for (const wordLength of lengths) {\n      wordsList.push(await buildMemorableWord(wordLength, nextInt));\n    }\n\n    return wordsList.join(\" \");\n  }\n\n  let currentPattern = pattern;\n  let result = prefix;\n  let validChars: string[] | null = null;\n\n  if (!memorable) {\n    validChars = buildValidChars(pattern);\n  }\n\n  if (!ignoreSecurityRecommendations) {\n    if (memorable) {\n      const estimate = estimateMemorableEntropy(length, prefix);\n      if (estimate.entropyBits < MIN_ENTROPY_BITS) {\n        securityRecommendation(\n          `estimated entropy ${estimate.entropyBits.toFixed(1)} bits is below ${MIN_ENTROPY_BITS} bits`,\n          `Use length >= ${estimate.recommendedLength} or set memorable: false.`,\n        );\n      }\n    } else if (validChars) {\n      const estimate = estimatePatternEntropy(\n        validChars.length,\n        length,\n        prefix,\n      );\n      if (estimate.entropyBits < MIN_ENTROPY_BITS) {\n        const recommendation =\n          estimate.recommendedLength === null\n            ? \"Use a broader pattern to increase the character set.\"\n            : `Use length >= ${estimate.recommendedLength} or broaden the pattern.`;\n        securityRecommendation(\n          `estimated entropy ${estimate.entropyBits.toFixed(1)} bits is below ${MIN_ENTROPY_BITS} bits`,\n          recommendation,\n        );\n      }\n    }\n  }\n\n  while (result.length < length) {\n    let char = \"\";\n\n    if (memorable) {\n      currentPattern = result.match(CONSONANT) ? VOWEL : CONSONANT;\n      const code = await nextInt(33, 126);\n      char = String.fromCharCode(code).toLowerCase();\n    } else if (validChars) {\n      const index = await nextInt(0, validChars.length);\n      char = validChars[index] ?? \"\";\n    }\n\n    if (char.match(currentPattern)) {\n      result += char;\n    }\n  }\n\n  return result;\n};\n",
    "type ArgValue = string | boolean | string[] | undefined;\n\ntype ParsedArgs = {\n  _: string[];\n  [key: string]: ArgValue;\n};\n\nconst parseArgs = (args: string[]): ParsedArgs => {\n  const parsed: ParsedArgs = { _: [] };\n  const set = (key: string, value: ArgValue = true) => {\n    parsed[key] = value;\n  };\n\n  for (let i = 0; i < args.length; i += 1) {\n    const arg = args[i];\n    if (arg === undefined) {\n      continue;\n    }\n    if (arg === \"--\") {\n      parsed._.push(...args.slice(i + 1));\n      break;\n    }\n    if (arg.startsWith(\"--\")) {\n      const [rawKey, rawValue] = arg.slice(2).split(\"=\");\n      if (!rawKey) {\n        continue;\n      }\n      if (rawValue !== undefined) {\n        set(rawKey, rawValue);\n        continue;\n      }\n      const next = args[i + 1];\n      if (next && !next.startsWith(\"-\")) {\n        set(rawKey, next);\n        i += 1;\n      } else {\n        set(rawKey, true);\n      }\n      continue;\n    }\n    if (arg.startsWith(\"-\")) {\n      const [rawKey, rawValue] = arg.slice(1).split(\"=\");\n      if (!rawKey) {\n        continue;\n      }\n      if (rawValue !== undefined) {\n        set(rawKey, rawValue);\n        continue;\n      }\n      const next = args[i + 1];\n      if (next && !next.startsWith(\"-\")) {\n        set(rawKey, next);\n        i += 1;\n      } else {\n        set(rawKey, true);\n      }\n      continue;\n    }\n    parsed._.push(arg);\n  }\n\n  return parsed;\n};\n\nconst pickValue = (args: ParsedArgs, keys: string[]): ArgValue => {\n  for (const key of keys) {\n    if (args[key] !== undefined) {\n      return args[key];\n    }\n  }\n  return undefined;\n};\n\nconst asBoolean = (value: ArgValue): boolean => {\n  if (value === undefined) return false;\n  if (value === true) return true;\n  if (Array.isArray(value)) return value.length > 0;\n  if (typeof value === \"string\") {\n    const normalized = value.toLowerCase();\n    return normalized !== \"false\" && normalized !== \"0\";\n  }\n  return Boolean(value);\n};\n\nconst asString = (value: ArgValue): string | undefined => {\n  if (value === undefined) return undefined;\n  if (Array.isArray(value)) return value[0];\n  return typeof value === \"string\" ? value : String(value);\n};\n\nconst puts = console.log;\n\nconst DEFAULT_LENGTH = 16;\nconst DEFAULT_MEMORABLE_LENGTH = 20;\nconst DEFAULT_WORDS = 3;\n\nconst options = [\n  {\n    flags: \"-l, --length <n>\",\n    description: `Password length [default: ${DEFAULT_LENGTH}, or ${DEFAULT_MEMORABLE_LENGTH} with --memorable]`,\n  },\n  { flags: \"-m, --memorable\", description: \"Generates a memorable password\" },\n  {\n    flags: \"-c, --non-memorable\",\n    description: \"Generates a non memorable password [default]\",\n  },\n  {\n    flags: \"-p, --pattern <regex>\",\n    description: \"Pattern to match for the generated password\",\n  },\n  {\n    flags: \"-i, --ignore-security-recommendations\",\n    description: \"Ignore security recommendations\",\n  },\n  {\n    flags: \"-s, -sN, --words <n>\",\n    description:\n      \"Generate N memorable words (3-7 letters) separated by spaces [default: 3]\",\n  },\n  { flags: \"-h, --help\", description: \"Displays this help\" },\n];\n\nconst showHelp = () => {\n  puts(\"Generates a secure password\\r\\n\");\n  puts(\"Options:\");\n  for (const option of options) {\n    puts(`  ${option.flags}: ${option.description}`);\n  }\n};\n\nexport const runCli = async (argv = process.argv.slice(2)) => {\n  const parsed = parseArgs(argv);\n  const help = asBoolean(pickValue(parsed, [\"h\", \"help\"]));\n  if (help) {\n    showHelp();\n    return;\n  }\n\n  const { generatePasswordWithOptions } = await import(\"./index.js\");\n  const patternRaw = asString(pickValue(parsed, [\"p\", \"pattern\"]));\n  const suffixedWordsKey = Object.keys(parsed).find((key) =>\n    /^s\\d+$/.test(key),\n  );\n  const wordsRaw = pickValue(parsed, [\"s\", \"words\", \"phrase\", \"passphrase\"]);\n  let words: number | undefined;\n  if (suffixedWordsKey) {\n    words = Number(suffixedWordsKey.slice(1));\n  } else if (wordsRaw !== undefined) {\n    words = wordsRaw === true ? DEFAULT_WORDS : Number(wordsRaw);\n  }\n\n  const hasMemorable = pickValue(parsed, [\"m\", \"memorable\"]) !== undefined;\n  const hasNonMemorable =\n    pickValue(parsed, [\"c\", \"non-memorable\", \"nonmemorable\"]) !== undefined;\n  let memorable = hasMemorable ? true : false;\n  if (hasNonMemorable) {\n    memorable = false;\n  }\n\n  const pattern = patternRaw ? new RegExp(patternRaw) : undefined;\n  if (pattern) {\n    memorable = false;\n  }\n\n  const lengthRaw = asString(pickValue(parsed, [\"l\", \"length\"]));\n  const lengthValue = lengthRaw !== undefined ? Number(lengthRaw) : undefined;\n  const length =\n    lengthValue !== undefined\n      ? lengthValue\n      : words !== undefined\n        ? undefined\n        : memorable\n          ? DEFAULT_MEMORABLE_LENGTH\n          : DEFAULT_LENGTH;\n  const ignoreSecurityRecommendations = asBoolean(\n    pickValue(parsed, [\n      \"i\",\n      \"ignore-security-recommendations\",\n      \"ignoreSecurityRecommendations\",\n    ]),\n  );\n\n  const options: {\n    length?: number;\n    memorable: boolean;\n    pattern?: RegExp;\n    ignoreSecurityRecommendations: boolean;\n    words?: number;\n  } = {\n    memorable,\n    ignoreSecurityRecommendations,\n  };\n\n  if (pattern) {\n    options.pattern = pattern;\n  }\n  if (typeof length === \"number\" && Number.isFinite(length)) {\n    options.length = length;\n  }\n  if (words !== undefined) {\n    options.words = words;\n  }\n\n  const pass = await generatePasswordWithOptions(options);\n\n  puts(pass);\n};\n"
  ],
  "mappings": "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",
  "debugId": "164708593EC1153464756E2164756E21",
  "names": []
}