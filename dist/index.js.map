{
  "version": 3,
  "sources": ["../src/random.ts", "../src/index.ts"],
  "sourcesContent": [
    "const crypto = globalThis.crypto!;\nconst MAX_RANDOM_BYTES = 65_536;\n\ntype RandomBytes = (length: number) => Promise<Uint8Array>;\ntype CryptoSource = Pick<Crypto, \"getRandomValues\" | \"subtle\">;\n\nexport const getRandomBytes: RandomBytes = async (\n  length: number,\n): Promise<Uint8Array> => {\n  if (!Number.isFinite(length) || length < 0) {\n    throw new RangeError(\"length must be a non-negative finite number\");\n  }\n\n  const buffer = new Uint8Array(length);\n  for (let offset = 0; offset < length; offset += MAX_RANDOM_BYTES) {\n    const end = Math.min(offset + MAX_RANDOM_BYTES, length);\n    crypto.getRandomValues(buffer.subarray(offset, end));\n  }\n  return buffer;\n};\n\nexport const createDeterministicRandomBytes = async (\n  entropy: Uint8Array,\n  cryptoSource: CryptoSource = crypto,\n): Promise<RandomBytes> => {\n  if (entropy.length === 0) {\n    throw new RangeError(\"entropy must not be empty\");\n  }\n  if (!cryptoSource.subtle) {\n    throw new Error(\"WebCrypto subtle is required for deterministic entropy\");\n  }\n\n  const keyData = new Uint8Array(entropy).buffer;\n  const key = await cryptoSource.subtle.importKey(\n    \"raw\",\n    keyData,\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"],\n  );\n\n  let counter = 0n;\n  const counterBytes = new Uint8Array(8);\n  const counterView = new DataView(counterBytes.buffer);\n  counterView.setBigUint64(0, counter, false);\n  const deterministicRandomBytes: RandomBytes = async (length: number) => {\n    if (!Number.isFinite(length) || length < 0) {\n      throw new RangeError(\"length must be a non-negative finite number\");\n    }\n\n    const buffer = new Uint8Array(length);\n    let offset = 0;\n\n    while (offset < length) {\n      counterView.setBigUint64(0, counter, false);\n      counter += 1n;\n      const block = new Uint8Array(\n        await cryptoSource.subtle.sign(\"HMAC\", key, counterBytes),\n      );\n      const take = Math.min(block.length, length - offset);\n      buffer.set(block.subarray(0, take), offset);\n      offset += take;\n    }\n\n    return buffer;\n  };\n\n  return deterministicRandomBytes;\n};\n\nexport const randomInt = async (\n  min: number,\n  max: number,\n  randomBytes: RandomBytes = getRandomBytes,\n): Promise<number> => {\n  if (!Number.isFinite(min) || !Number.isFinite(max)) {\n    throw new RangeError(\"min and max must be finite numbers\");\n  }\n  if (max <= min) {\n    throw new RangeError(\"max must be greater than min\");\n  }\n\n  const range = max - min;\n  if (range === 1) {\n    return min;\n  }\n\n  const bytesNeeded = Math.ceil(Math.log2(range) / 8);\n  const maxValue = 256 ** bytesNeeded;\n  const limit = maxValue - (maxValue % range);\n\n  let value = limit;\n  while (value >= limit) {\n    const bytes = await randomBytes(bytesNeeded);\n    value = 0;\n    for (const byte of bytes) {\n      value = value * 256 + byte;\n    }\n  }\n\n  return min + (value % range);\n};\n",
    "import {\n  createDeterministicRandomBytes,\n  getRandomBytes,\n  randomInt,\n} from \"./random.js\";\n\nexport type GenerateOptions = {\n  length?: number;\n  memorable?: boolean;\n  pattern?: RegExp;\n  prefix?: string;\n  ignoreSecurityRecommendations?: boolean;\n  entropy?: Uint8Array | string;\n  words?: number;\n};\n\nconst VOWELS = \"aeiou\";\nconst CONSONANTS = \"bcdfghjklmnpqrstvwxyz\";\nconst VOWEL = new RegExp(`[${VOWELS}]$`, \"i\");\nconst CONSONANT = new RegExp(`[${CONSONANTS}]$`, \"i\");\nconst DEFAULT_PATTERN = /\\w/;\nconst DEFAULT_LENGTH = 12;\nconst MIN_ENTROPY_BITS = 64;\nconst MIN_WORD_LENGTH = 3;\nconst MAX_WORD_LENGTH = 7;\nconst textEncoder = new TextEncoder();\n\nconst normalizeOptions = (options: GenerateOptions | undefined) => {\n  const lengthRaw = options?.length;\n  const memorableRaw = options?.memorable;\n  const patternRaw = options?.pattern;\n  const prefixRaw = options?.prefix;\n  const ignoreSecurityRecommendationsRaw =\n    options?.ignoreSecurityRecommendations;\n  const entropyRaw = options?.entropy;\n  const wordsRaw = options?.words;\n\n  const length = lengthRaw ?? DEFAULT_LENGTH;\n  const memorable = memorableRaw ?? false;\n  const pattern = patternRaw ?? DEFAULT_PATTERN;\n  const prefix = prefixRaw ?? \"\";\n\n  return {\n    length,\n    memorable,\n    pattern,\n    prefix: String(prefix),\n    ignoreSecurityRecommendations: ignoreSecurityRecommendationsRaw ?? false,\n    entropy: entropyRaw,\n    words: wordsRaw,\n  };\n};\n\nconst ensureSafeInteger = (value: number, name: string) => {\n  if (!Number.isSafeInteger(value)) {\n    throw new RangeError(`${name} must be a safe integer`);\n  }\n};\n\nconst ensureRegExp = (value: unknown) => {\n  if (!(value instanceof RegExp)) {\n    throw new TypeError(\"pattern must be a RegExp\");\n  }\n};\n\nconst normalizeEntropy = (entropy: Uint8Array | string | undefined) => {\n  if (entropy === undefined) {\n    return undefined;\n  }\n  if (typeof entropy === \"string\") {\n    return textEncoder.encode(entropy);\n  }\n  if (entropy instanceof Uint8Array) {\n    return entropy;\n  }\n  throw new TypeError(\"entropy must be a Uint8Array or string\");\n};\n\nconst matchesPattern = (pattern: RegExp, char: string) => {\n  pattern.lastIndex = 0;\n  return pattern.test(char);\n};\n\nconst buildValidChars = (pattern: RegExp) => {\n  const validChars: string[] = [];\n  for (let i = 33; i <= 126; i += 1) {\n    const char = String.fromCharCode(i);\n    if (matchesPattern(pattern, char)) {\n      validChars.push(char);\n    }\n  }\n  if (validChars.length === 0) {\n    throw new Error(\n      `Could not find characters that match the password pattern ${pattern}. Patterns must match individual characters, not the password as a whole.`,\n    );\n  }\n  return validChars;\n};\n\nconst estimatePatternEntropy = (\n  alphabetSize: number,\n  length: number,\n  prefix: string,\n) => {\n  const effectiveLength = Math.max(0, length - prefix.length);\n  const bitsPerChar = alphabetSize > 1 ? Math.log2(alphabetSize) : 0;\n  const entropyBits = bitsPerChar * effectiveLength;\n  const recommendedLength =\n    bitsPerChar > 0\n      ? prefix.length + Math.ceil(MIN_ENTROPY_BITS / bitsPerChar)\n      : null;\n\n  return {\n    effectiveLength,\n    entropyBits,\n    recommendedLength,\n  };\n};\n\nconst estimateMemorableEntropy = (length: number, prefix: string) => {\n  const effectiveLength = Math.max(0, length - prefix.length);\n  let entropyBits = 0;\n  let expectsVowel = CONSONANT.test(prefix);\n\n  for (let i = 0; i < effectiveLength; i += 1) {\n    const alphabetSize = expectsVowel ? VOWELS.length : CONSONANTS.length;\n    entropyBits += Math.log2(alphabetSize);\n    expectsVowel = !expectsVowel;\n  }\n\n  let recommendedLength = prefix.length;\n  let recommendationBits = 0;\n  expectsVowel = CONSONANT.test(prefix);\n  while (recommendationBits < MIN_ENTROPY_BITS) {\n    const alphabetSize = expectsVowel ? VOWELS.length : CONSONANTS.length;\n    recommendationBits += Math.log2(alphabetSize);\n    expectsVowel = !expectsVowel;\n    recommendedLength += 1;\n  }\n\n  return {\n    effectiveLength,\n    entropyBits,\n    recommendedLength,\n  };\n};\n\nconst MEMORABLE_RECOMMENDED_LENGTH = estimateMemorableEntropy(\n  0,\n  \"\",\n).recommendedLength;\n\nconst buildMemorableWord = async (\n  length: number,\n  nextInt: (min: number, max: number) => Promise<number>,\n) => {\n  let expectsVowel = false;\n  let word = \"\";\n\n  for (let i = 0; i < length; i += 1) {\n    const alphabet = expectsVowel ? VOWELS : CONSONANTS;\n    const index = await nextInt(0, alphabet.length);\n    word += alphabet[index] ?? \"\";\n    expectsVowel = !expectsVowel;\n  }\n\n  return word;\n};\n\nconst buildWordLengths = async (\n  count: number,\n  nextInt: (min: number, max: number) => Promise<number>,\n  targetLength?: number,\n) => {\n  const lengths: number[] = [];\n  let total = 0;\n\n  for (let i = 0; i < count; i += 1) {\n    const length = await nextInt(MIN_WORD_LENGTH, MAX_WORD_LENGTH + 1);\n    lengths.push(length);\n    total += length;\n  }\n\n  if (targetLength !== undefined && total < targetLength) {\n    const adjustable = Array.from({ length: count }, (_, idx) => idx);\n    let remaining = targetLength - total;\n\n    while (remaining > 0 && adjustable.length > 0) {\n      const pickIndex = await nextInt(0, adjustable.length);\n      const wordIndex = adjustable[pickIndex];\n      if (wordIndex === undefined) {\n        break;\n      }\n      const currentLength = lengths[wordIndex];\n      if (currentLength === undefined) {\n        break;\n      }\n      if (currentLength < MAX_WORD_LENGTH) {\n        lengths[wordIndex] = currentLength + 1;\n        remaining -= 1;\n        if (lengths[wordIndex] === MAX_WORD_LENGTH) {\n          adjustable.splice(pickIndex, 1);\n        }\n      } else {\n        adjustable.splice(pickIndex, 1);\n      }\n    }\n  }\n\n  return lengths;\n};\n\nconst securityRecommendation = (reason: string, recommendation: string) => {\n  throw new Error(\n    `Security recommendation: ${reason}. ${recommendation} To override, pass { ignoreSecurityRecommendations: true }.`,\n  );\n};\n\nexport const generatePassword = async (\n  length?: number,\n  memorable?: boolean,\n  pattern?: RegExp,\n  prefix?: string,\n): Promise<string> => {\n  const options: GenerateOptions = {};\n  if (length !== undefined) {\n    options.length = length;\n  }\n  if (memorable !== undefined) {\n    options.memorable = memorable;\n  }\n  if (pattern !== undefined) {\n    options.pattern = pattern;\n  }\n  if (prefix !== undefined) {\n    options.prefix = prefix;\n  }\n\n  return generatePasswordWithOptions(\n    Object.keys(options).length ? options : undefined,\n  );\n};\n\nexport const generatePasswordWithOptions = async (\n  options?: GenerateOptions,\n): Promise<string> => {\n  const {\n    length,\n    memorable,\n    pattern,\n    prefix,\n    ignoreSecurityRecommendations,\n    entropy,\n    words,\n  } = normalizeOptions(options);\n\n  ensureSafeInteger(length, \"length\");\n  if (length < 0) {\n    throw new RangeError(\"length must be a non-negative integer\");\n  }\n  ensureRegExp(pattern);\n  if (words !== undefined) {\n    ensureSafeInteger(words, \"words\");\n    if (words <= 0) {\n      throw new RangeError(\"words must be a positive integer\");\n    }\n  }\n  if (words !== undefined && prefix !== \"\") {\n    throw new Error(\"prefix is not supported when words are enabled\");\n  }\n\n  const entropyBytes = normalizeEntropy(entropy);\n  const randomBytes = entropyBytes\n    ? await createDeterministicRandomBytes(entropyBytes)\n    : getRandomBytes;\n  const nextInt = (min: number, max: number) =>\n    randomInt(min, max, randomBytes);\n\n  if (words !== undefined) {\n    if (\n      !ignoreSecurityRecommendations &&\n      words * MAX_WORD_LENGTH < MEMORABLE_RECOMMENDED_LENGTH\n    ) {\n      const recommendedWords = Math.ceil(\n        MEMORABLE_RECOMMENDED_LENGTH / MAX_WORD_LENGTH,\n      );\n      securityRecommendation(\n        `word count ${words} cannot reach ${MIN_ENTROPY_BITS} bits with ${MIN_WORD_LENGTH}-${MAX_WORD_LENGTH} letter words`,\n        `Use words >= ${recommendedWords}.`,\n      );\n    }\n\n    const targetLength = ignoreSecurityRecommendations\n      ? undefined\n      : MEMORABLE_RECOMMENDED_LENGTH;\n    const lengths = await buildWordLengths(words, nextInt, targetLength);\n    const wordsList: string[] = [];\n\n    for (const wordLength of lengths) {\n      wordsList.push(await buildMemorableWord(wordLength, nextInt));\n    }\n\n    return wordsList.join(\" \");\n  }\n\n  let currentPattern = pattern;\n  let result = prefix;\n  let validChars: string[] | null = null;\n\n  if (!memorable) {\n    validChars = buildValidChars(pattern);\n  }\n\n  if (!ignoreSecurityRecommendations) {\n    if (memorable) {\n      const estimate = estimateMemorableEntropy(length, prefix);\n      if (estimate.entropyBits < MIN_ENTROPY_BITS) {\n        securityRecommendation(\n          `estimated entropy ${estimate.entropyBits.toFixed(1)} bits is below ${MIN_ENTROPY_BITS} bits`,\n          `Use length >= ${estimate.recommendedLength} or set memorable: false.`,\n        );\n      }\n    } else if (validChars) {\n      const estimate = estimatePatternEntropy(\n        validChars.length,\n        length,\n        prefix,\n      );\n      if (estimate.entropyBits < MIN_ENTROPY_BITS) {\n        const recommendation =\n          estimate.recommendedLength === null\n            ? \"Use a broader pattern to increase the character set.\"\n            : `Use length >= ${estimate.recommendedLength} or broaden the pattern.`;\n        securityRecommendation(\n          `estimated entropy ${estimate.entropyBits.toFixed(1)} bits is below ${MIN_ENTROPY_BITS} bits`,\n          recommendation,\n        );\n      }\n    }\n  }\n\n  while (result.length < length) {\n    let char = \"\";\n\n    if (memorable) {\n      currentPattern = result.match(CONSONANT) ? VOWEL : CONSONANT;\n      const code = await nextInt(33, 126);\n      char = String.fromCharCode(code).toLowerCase();\n    } else if (validChars) {\n      const index = await nextInt(0, validChars.length);\n      char = validChars[index] ?? \"\";\n    }\n\n    if (char.match(currentPattern)) {\n      result += char;\n    }\n  }\n\n  return result;\n};\n"
  ],
  "mappings": "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",
  "debugId": "590DE33B76F9D4FC64756E2164756E21",
  "names": []
}